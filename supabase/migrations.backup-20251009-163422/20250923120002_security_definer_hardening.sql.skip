-- =====================================================
-- SECURITY DEFINER FUNCTION HARDENING
-- Migration: 20250923120002_security_definer_hardening.sql
-- Priority: HIGH - Deploy within 48 hours
-- =====================================================

-- =====================================================
-- PHASE 1: HARDEN SECURITY DEFINER FUNCTIONS
-- =====================================================

-- Drop existing functions to recreate with security hardening
DROP FUNCTION IF EXISTS set_app_context(TEXT);
-- Skipping get_app_context() because policies depend on it
-- DROP FUNCTION IF EXISTS get_app_context();
DROP FUNCTION IF EXISTS create_user_context(UUID, TEXT, TEXT, JSONB, JSONB);
DROP FUNCTION IF EXISTS log_context_interaction(UUID, TEXT, TEXT, JSONB, UUID, TIMESTAMP WITH TIME ZONE);
DROP FUNCTION IF EXISTS create_work_buddy_profile(UUID, TEXT, JSONB, JSONB);
DROP FUNCTION IF EXISTS schedule_work_buddy_appointment(UUID, UUID, JSONB, TIMESTAMP WITH TIME ZONE);
DROP FUNCTION IF EXISTS update_collaboration_traits(UUID, TEXT, INTEGER);

-- =====================================================
-- HARDENED set_app_context FUNCTION
-- =====================================================

CREATE OR REPLACE FUNCTION set_app_context(context_name TEXT)
RETURNS void AS $$
BEGIN
  -- Input validation
  IF context_name IS NULL THEN
    RAISE EXCEPTION 'Context name cannot be null';
  END IF;

  IF length(context_name) = 0 OR length(context_name) > 100 THEN
    RAISE EXCEPTION 'Context name must be between 1 and 100 characters';
  END IF;

  -- Whitelist allowed contexts (critical security control)
  IF context_name NOT IN ('oriva-core', 'oo-work-buddy', 'oo-dating', 'oo-fitness', 'oo-finance') THEN
    RAISE EXCEPTION 'Unauthorized context: %. Only whitelisted contexts are allowed.', context_name;
  END IF;

  -- Additional security: verify user is authenticated
  IF auth.uid() IS NULL THEN
    RAISE EXCEPTION 'Authentication required to set app context';
  END IF;

  -- Log context switch for audit trail
  PERFORM log_security_event(
    'data_access',
    'app_context',
    'context_switch',
    jsonb_build_object('new_context', context_name, 'user_id', auth.uid())
  );

  PERFORM set_config('app.context', context_name, true);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Restrict access and grant specific permissions
REVOKE ALL ON FUNCTION set_app_context(TEXT) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION set_app_context(TEXT) TO authenticated;

-- =====================================================
-- HARDENED get_app_context FUNCTION
-- =====================================================

CREATE OR REPLACE FUNCTION get_app_context()
RETURNS TEXT AS $$
DECLARE
  current_context TEXT;
BEGIN
  -- Get current context with fallback to oriva-core
  current_context := COALESCE(current_setting('app.context', true), 'oriva-core');

  -- Validate context is still in whitelist
  IF current_context NOT IN ('oriva-core', 'oo-work-buddy', 'oo-dating', 'oo-fitness', 'oo-finance') THEN
    -- Reset to safe default if invalid context detected
    PERFORM set_config('app.context', 'oriva-core', true);
    current_context := 'oriva-core';

    -- Log potential security issue
    PERFORM log_security_event(
      'policy_violation',
      'app_context',
      'invalid_context_detected',
      jsonb_build_object('invalid_context', current_context, 'reset_to', 'oriva-core')
    );
  END IF;

  RETURN current_context;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

REVOKE ALL ON FUNCTION get_app_context() FROM PUBLIC;
GRANT EXECUTE ON FUNCTION get_app_context() TO authenticated, service_role;

-- =====================================================
-- HARDENED create_user_context FUNCTION
-- =====================================================

CREATE OR REPLACE FUNCTION create_user_context(
  p_user_id UUID,
  p_context TEXT,
  p_bio TEXT DEFAULT NULL,
  p_traits JSONB DEFAULT '{}',
  p_preferences JSONB DEFAULT '{}'
)
RETURNS UUID AS $$
DECLARE
  new_context_id UUID;
  max_contexts_per_user INTEGER := 10; -- Prevent context spam
  current_context_count INTEGER;
BEGIN
  -- Input validation
  IF p_user_id IS NULL THEN
    RAISE EXCEPTION 'User ID cannot be null';
  END IF;

  IF p_context IS NULL OR length(p_context) = 0 OR length(p_context) > 100 THEN
    RAISE EXCEPTION 'Invalid context name';
  END IF;

  -- Security: Only allow users to create contexts for themselves
  IF auth.uid() != p_user_id THEN
    RAISE EXCEPTION 'Users can only create contexts for themselves';
  END IF;

  -- Validate context is whitelisted
  IF p_context NOT IN ('oriva-core', 'oo-work-buddy', 'oo-dating', 'oo-fitness', 'oo-finance') THEN
    RAISE EXCEPTION 'Unauthorized context: %', p_context;
  END IF;

  -- Check context limit per user
  SELECT COUNT(*) INTO current_context_count
  FROM user_contexts
  WHERE user_id = p_user_id AND is_active = true;

  IF current_context_count >= max_contexts_per_user THEN
    RAISE EXCEPTION 'Maximum context limit reached. User can have at most % active contexts', max_contexts_per_user;
  END IF;

  -- Validate JSON input
  IF p_traits IS NOT NULL AND NOT (p_traits ? 'version' OR jsonb_typeof(p_traits) = 'object') THEN
    RAISE EXCEPTION 'Invalid traits JSON structure';
  END IF;

  IF p_preferences IS NOT NULL AND NOT (jsonb_typeof(p_preferences) = 'object') THEN
    RAISE EXCEPTION 'Invalid preferences JSON structure';
  END IF;

  -- Sanitize bio length
  IF p_bio IS NOT NULL AND length(p_bio) > 500 THEN
    p_bio := substring(p_bio FROM 1 FOR 500);
  END IF;

  INSERT INTO user_contexts (user_id, context, bio, traits, preferences)
  VALUES (p_user_id, p_context, p_bio, COALESCE(p_traits, '{}'), COALESCE(p_preferences, '{}'))
  ON CONFLICT (user_id, context)
  DO UPDATE SET
    bio = EXCLUDED.bio,
    traits = EXCLUDED.traits,
    preferences = EXCLUDED.preferences,
    updated_at = NOW()
  RETURNING id INTO new_context_id;

  -- Log context creation
  PERFORM log_security_event(
    'data_access',
    'user_contexts',
    'create_context',
    jsonb_build_object('context_id', new_context_id, 'context', p_context, 'user_id', p_user_id)
  );

  RETURN new_context_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

REVOKE ALL ON FUNCTION create_user_context(UUID, TEXT, TEXT, JSONB, JSONB) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION create_user_context(UUID, TEXT, TEXT, JSONB, JSONB) TO authenticated;

-- =====================================================
-- HARDENED log_context_interaction FUNCTION
-- =====================================================

CREATE OR REPLACE FUNCTION log_context_interaction(
  p_user_id UUID,
  p_context TEXT,
  p_type TEXT,
  p_data JSONB DEFAULT '{}',
  p_target_user_id UUID DEFAULT NULL,
  p_scheduled_at TIMESTAMP WITH TIME ZONE DEFAULT NULL
)
RETURNS UUID AS $$
DECLARE
  interaction_id UUID;
  max_interactions_per_hour INTEGER := 100; -- Rate limiting
  recent_interaction_count INTEGER;
BEGIN
  -- Input validation
  IF p_user_id IS NULL THEN
    RAISE EXCEPTION 'User ID cannot be null';
  END IF;

  IF p_context IS NULL OR p_type IS NULL THEN
    RAISE EXCEPTION 'Context and type cannot be null';
  END IF;

  -- Security: Only allow users to log interactions for themselves
  IF auth.uid() != p_user_id AND current_user != 'service_role' THEN
    RAISE EXCEPTION 'Users can only log interactions for themselves';
  END IF;

  -- Validate context
  IF p_context NOT IN ('oriva-core', 'oo-work-buddy', 'oo-dating', 'oo-fitness', 'oo-finance') THEN
    RAISE EXCEPTION 'Unauthorized context: %', p_context;
  END IF;

  -- Rate limiting: check interactions in last hour
  SELECT COUNT(*) INTO recent_interaction_count
  FROM context_interactions
  WHERE user_id = p_user_id
    AND created_at > NOW() - INTERVAL '1 hour';

  IF recent_interaction_count >= max_interactions_per_hour THEN
    RAISE EXCEPTION 'Rate limit exceeded. Maximum % interactions per hour', max_interactions_per_hour;
  END IF;

  -- Validate JSON input
  IF p_data IS NOT NULL AND jsonb_typeof(p_data) != 'object' THEN
    RAISE EXCEPTION 'Data must be a valid JSON object';
  END IF;

  -- Sanitize scheduled_at (cannot be too far in the future)
  IF p_scheduled_at IS NOT NULL AND p_scheduled_at > NOW() + INTERVAL '1 year' THEN
    RAISE EXCEPTION 'Scheduled time cannot be more than 1 year in the future';
  END IF;

  INSERT INTO context_interactions (
    user_id, context, type, data, target_user_id, scheduled_at
  )
  VALUES (
    p_user_id, p_context, p_type, COALESCE(p_data, '{}'), p_target_user_id, p_scheduled_at
  )
  RETURNING id INTO interaction_id;

  RETURN interaction_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

REVOKE ALL ON FUNCTION log_context_interaction(UUID, TEXT, TEXT, JSONB, UUID, TIMESTAMP WITH TIME ZONE) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION log_context_interaction(UUID, TEXT, TEXT, JSONB, UUID, TIMESTAMP WITH TIME ZONE) TO authenticated, service_role;

-- =====================================================
-- WORK BUDDY SPECIFIC HARDENED FUNCTIONS
-- =====================================================

-- Hardened create_work_buddy_profile
CREATE OR REPLACE FUNCTION create_work_buddy_profile(
  p_user_id UUID,
  p_bio TEXT DEFAULT NULL,
  p_working_hours JSONB DEFAULT '{"start": "09:00", "end": "17:00"}',
  p_collaboration_preferences JSONB DEFAULT '{}'
)
RETURNS UUID AS $$
DECLARE
  profile_id UUID;
  default_traits JSONB;
BEGIN
  -- Security: Only allow users to create profiles for themselves
  IF auth.uid() != p_user_id THEN
    RAISE EXCEPTION 'Users can only create Work Buddy profiles for themselves';
  END IF;

  -- Validate working hours JSON structure
  IF p_working_hours IS NOT NULL AND NOT (p_working_hours ? 'start' AND p_working_hours ? 'end') THEN
    RAISE EXCEPTION 'Working hours must include start and end times';
  END IF;

  -- Set default traits for Work Buddy context
  default_traits := jsonb_build_object(
    'punctuality', 0.8,
    'collaboration', 0.8,
    'communication', 0.8,
    'availability', 0.8,
    'responsiveness', 0.8,
    'version', '1.0'
  );

  -- Create the context profile using hardened function
  SELECT create_user_context(
    p_user_id,
    'oo-work-buddy',
    p_bio,
    default_traits,
    jsonb_build_object(
      'working_hours', COALESCE(p_working_hours, '{"start": "09:00", "end": "17:00"}'),
      'collaboration_preferences', COALESCE(p_collaboration_preferences, '{}')
    )
  ) INTO profile_id;

  RETURN profile_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

REVOKE ALL ON FUNCTION create_work_buddy_profile(UUID, TEXT, JSONB, JSONB) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION create_work_buddy_profile(UUID, TEXT, JSONB, JSONB) TO authenticated;

-- =====================================================
-- FUNCTION SECURITY AUDIT
-- =====================================================

-- Create function to audit all SECURITY DEFINER functions
CREATE OR REPLACE FUNCTION audit_security_definer_functions()
RETURNS TABLE (
  function_name TEXT,
  function_security TEXT,
  granted_to TEXT[],
  last_modified TIMESTAMP WITH TIME ZONE
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    p.proname::TEXT as function_name,
    CASE
      WHEN p.prosecdef THEN 'SECURITY DEFINER'
      ELSE 'SECURITY INVOKER'
    END as function_security,
    ARRAY(
      SELECT r.rolname
      FROM pg_proc_acl pa
      JOIN pg_roles r ON pa.grantee = r.oid
      WHERE pa.objoid = p.oid
      AND pa.privilege_type = 'EXECUTE'
    ) as granted_to,
    NULL::TIMESTAMP WITH TIME ZONE as last_modified
  FROM pg_proc p
  JOIN pg_namespace n ON p.pronamespace = n.oid
  WHERE n.nspname = 'public'
    AND p.prosecdef = true
  ORDER BY p.proname;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Only admins can audit functions
REVOKE ALL ON FUNCTION audit_security_definer_functions() FROM PUBLIC;
-- Grant will be added in admin setup

-- =====================================================
-- LOG SECURITY HARDENING COMPLETION
-- =====================================================

SELECT log_security_event(
  'security_fix',
  'functions',
  'security_definer_hardening',
  '{"migration": "20250923120002_security_definer_hardening", "functions_hardened": ["set_app_context", "get_app_context", "create_user_context", "log_context_interaction", "create_work_buddy_profile"]}'::JSONB
);

-- =====================================================
-- VERIFICATION QUERIES
-- =====================================================

-- Verify all SECURITY DEFINER functions have restricted access
SELECT * FROM audit_security_definer_functions();

-- Verify functions exist and are SECURITY DEFINER
SELECT
  proname as function_name,
  prosecdef as is_security_definer,
  proacl as access_privileges
FROM pg_proc p
JOIN pg_namespace n ON p.pronamespace = n.oid
WHERE n.nspname = 'public'
  AND proname IN ('set_app_context', 'get_app_context', 'create_user_context', 'log_context_interaction')
ORDER BY proname;

COMMENT ON MIGRATION IS 'Security hardening of all SECURITY DEFINER functions with input validation, rate limiting, and audit logging.';

-- End of migration